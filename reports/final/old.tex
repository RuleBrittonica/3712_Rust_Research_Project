As seen in the above examples, a na\"ive extraction is often not going to
compile. Free variables, non-local control flow and lifetimes make the extracted
fragment ill-typed. the purpose of REM is to repair these issues automatically,
producing a valid Rust program $P'$ while preserving the intent of the original
code. At a high level, REM applies three classes of fixes:

\begin{enumerate}[label=(\roman*)]
    \item Reifying non-local control flow into a small result enum.
    \item Inferring ownership for free variables (by value, \verb|&T|, or
    \verb|&mut T|) and,
    \item Adjusting lifetime parameters in an iterative manner, guided by
    \verb|rustc| until the borrow checker is satisfied.
\end{enumerate}

These steps transform a purely syntactic extraction into a valid program $P'$
that is much closer to what a developer would have written by hand.

\subsubsection*{Example: Simple Case}

In the toy example, extraction is trivial. REM observes that both \verb|x| and
\verb|y| can be moved by valuie into the new function, so the inferred signature
is simply:

\begin{minted}[linenos,breaklines, frame=none, fontsize=\small]{rust}
fn add(x: i32, y: i32) -> i32
\end{minted}

No further repairs are needed. This illustrates the best case: REM's analysis
immediately determines that the signature is valid Rust and human readable.

\subsubsection*{Example: Real World Case}

By contrast, in the \verb|extract_include_path| example
(\ref{content:bad_gitoxide_extraction}), naiive extraction fails. The plugin
incorrectly infers that the loop variable \verb|id| must be borrowed
(\verb|&SectionID|), and entirely misses the lifetime parameter \verb|<'a>|,
required to properly scope our mutable references to \verb|File| and
\verb|Vec<path>| throughout the entire function.

REM corrects this in several ways:
\begin{enumerate}
    \item It detects that \verb|id| is consumed at the call site, so ownership
    can be transferred rather than borrowed.
    \item It generalises lifetime parameters across both \verb|File<'a>| and
    \verb|Vec<Path<'a>>| to ensure consistent scoping.
    \item It replays \verb|cargo check| until no lifetime mismatches remain.
\end{enumerate}

The resulting signature is significantly more natural (in this case it is
identical to the manual extraction).

\begin{minted}[linenos,breaklines, frame=none, fontsize=\small]{rust}
fn extract_include_path<'a>(
    target_config: &mut File<'a>,
    include_paths: &mut Vec<Path<'a>>,
    id: SectionId)
\end{minted}

The shift from \verb|&SectionId| to \verb|SectionId| demonstrates REM's key
contribution: making semantically appropriate ownership decisions automatically,
while still producing code that compiles under Rust's strict type system.

% TODO if I end up writing an incrementally compiling version of CHARON, add
% that information here.