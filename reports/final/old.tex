As seen in the above examples, a na\"ive extraction is often not going to
compile. Free variables, non-local control flow and lifetimes make the extracted
fragment ill-typed. the purpose of REM is to repair these issues automatically,
producing a valid Rust program $P'$ while preserving the intent of the original
code. At a high level, REM applies three classes of fixes:

\begin{enumerate}[label=(\roman*)]
    \item Reifying non-local control flow into a small result enum.
    \item Inferring ownership for free variables (by value, \verb|&T|, or
    \verb|&mut T|) and,
    \item Adjusting lifetime parameters in an iterative manner, guided by
    \verb|rustc| until the borrow checker is satisfied.
\end{enumerate}

These steps transform a purely syntactic extraction into a valid program $P'$
that is much closer to what a developer would have written by hand.

\subsubsection*{Example: Simple Case}

In the toy example, extraction is trivial. REM observes that both \verb|x| and
\verb|y| can be moved by valuie into the new function, so the inferred signature
is simply:

\begin{minted}[linenos,breaklines, frame=none, fontsize=\small]{rust}
fn add(x: i32, y: i32) -> i32
\end{minted}

No further repairs are needed. This illustrates the best case: REM's analysis
immediately determines that the signature is valid Rust and human readable.

\subsubsection*{Example: Real World Case}

By contrast, in the \verb|extract_include_path| example
(\ref{content:bad_gitoxide_extraction}), naiive extraction fails. The plugin
incorrectly infers that the loop variable \verb|id| must be borrowed
(\verb|&SectionID|), and entirely misses the lifetime parameter \verb|<'a>|,
required to properly scope our mutable references to \verb|File| and
\verb|Vec<path>| throughout the entire function.

REM corrects this in several ways:
\begin{enumerate}
    \item It detects that \verb|id| is consumed at the call site, so ownership
    can be transferred rather than borrowed.
    \item It generalises lifetime parameters across both \verb|File<'a>| and
    \verb|Vec<Path<'a>>| to ensure consistent scoping.
    \item It replays \verb|cargo check| until no lifetime mismatches remain.
\end{enumerate}

The resulting signature is significantly more natural (in this case it is
identical to the manual extraction).

\begin{minted}[linenos,breaklines, frame=none, fontsize=\small]{rust}
fn extract_include_path<'a>(
    target_config: &mut File<'a>,
    include_paths: &mut Vec<Path<'a>>,
    id: SectionId)
\end{minted}

The shift from \verb|&SectionId| to \verb|SectionId| demonstrates REM's key
contribution: making semantically appropriate ownership decisions automatically,
while still producing code that compiles under Rust's strict type system.

% TODO if I end up writing an incrementally compiling version of CHARON, add
% that information here.

\section{Motivation: Why Verification is Essential}
\label{sec:motivation_verification}

Despite decades of work on automated refactoring, developers continue to show
reluctance to adopt such tools in practice. Empirical studies indicate that even
simple, “safe” refactorings such as renaming are frequently performed manually,
as programmers prefer to trust their own edits over opaque tool behaviour
\cite{OneThousandOneStories-SoftwareRefactoring}. This gap stems from usability
and, more fundamentally, from trust: if a refactoring tool cannot convincingly
guarantee that semantics are preserved, developers are unwilling to rely on it
for non-trivial code transformations.

The challenge is particularly problematic in Rust. Compared to languages like Java or
C\#, where refactorings operate largely at the syntactic or type level, Rust's
ownership and lifetime system makes every transformation potentially semantic.
Prior work shows that Extract Method in Rust is not merely ``cut and paste'' but
requires compiler-guided repairs such as introducing lifetime parameters,
reifying control flow, and inferring ownership modes
\cite{AdventureOfALifetime}. Crucially, the final step to the original REM
algorithm involves a series of non-trivial lifetime adjustments, guided by
\verb|rustc|, to ensure that the extracted code satisfies the borrow checker.
Whilst these are what is required to enable REM to succeed where na\"ive tools fail, but they also
make unintended behavioural or semantic changes more likely. A transformation that
compiles may nonetheless shift aliasing patterns, extend or shorten lifetimes,
or alter when resources are released — all of which are semantically observable
in Rust.

Traditional quality controls such as testing do not fill this gap. Tests, even
when comprehensive, explore only a small subset of possible inputs and
interleavings. In safety or performance critical domains, developers cannot
afford to accept the residual risk that untested paths diverge after a
refactoring. Verification, by contrast, offers a principled way to resolve the
trust deficit: it can establish - on a program by program basis - that for all
inputs respecting the refactored function's preconditioned, that the refactored
program is equivalent to the orginal. By integrating verification directly into
REM's pipeline, we address not only the technical challenge of making complex
extractions compile, but also the socio-technical challenge of making developers
confident that such transformations are behaviour-preserving.