\section*{Abstract}

Refactoring tools are central to modern software development, with extract-function refactorings used heavily in day-to-day work. For Rust, however, the combination of ownership, borrowing, and advanced type system features makes automated extract-function refactoring particularly challenging. Existing tools, including the original Rusty Extraction Maestro (REM) prototype, either rely on slow, compiler-based analysis, support only a restricted fragment of the language, or provide little assurance beyond ``it still compiles''.

This thesis presents REM2.0, a new extract-function and verification toolchain for Rust. REM2.0 works on top of \texttt{rust-analyzer} as a persistent daemon, reusing its analysis infrastructure to provide low-latency extract-function refactorings with a VSCode front-end. On top of this extraction engine, it adds a repairer that automatically adjusts lifetimes and function signatures when extraction exposes borrow-checker issues, and an optional verification pipeline that connects to \texttt{CHARON} and \texttt{AENEAS} to generate Coq proofs of equivalence between original and extracted functions for a supported subset of Rust.

The architecture is evaluated on three benchmark suites. First, on the original REM artefact (being forty cases drawn from real projects like gitoxide), REM2.0 achieves 100\% compatibility: it matches all original successes of the prototype and fixes several previous failures. It also reduces extraction latency from an average of around a thousand milliseconds to low single-digit milliseconds inside the daemon and well under a quarter of a second as perceived in the editor. Second, on a new corpus of forty feature-focused extractions from twenty highly starred GitHub repositories, REM2.0 successfully handles the majority of examples involving \texttt{async}/\texttt{await}, \texttt{const fn}, non-local control flow, generics, and higher-ranked trait bounds, with remaining failures concentrated around dynamic trait objects and complex generic bounds. Third, on a set of twenty verification benchmarks, the CHARON/AENEAS pipeline is able to construct end-to-end equivalence proofs for those cases that fall within its current subset, at a significantly higher performance cost than extraction but with correspondingly stronger guarantees.

Overall, the results show that a Rust Analyzer based design can provide fast, feature-rich extract-function refactoring for real Rust programs, while an opt-in verification pipeline can deliver machine-checked behaviour preservation for safety-critical refactorings. REM2.0 is therefore able to offer a highly practical path toward routinely verified refactoring in the Rust ecosystem.