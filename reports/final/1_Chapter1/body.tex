\chapter{Background}
\label{chap:lit_review}
\vspace*{-20mm}

Rust's ownership and borrowing discipline makes it possible to write
memory-safe, data-race–free systems code without a garbage collector, but it
also raises the bar for both automated refactoring and formal reasoning about
program behaviour~\cite{the_rust_language,automated_refactoring_of_rust_programs}.
This chapter surveys the background needed for the rest of this report. We begin
by reviewing refactoring and, in particular, the Extract Method transformation.
We then introduce Rust's ownership, borrowing, lifetimes, and control-flow
features, and explain how they interact with Extract Method. Building on this,
we describe prior work on automated refactoring for Rust, with a focus on
\emph{Adventure of a Lifetime} and the Rusty Extraction Maestro (REM)
prototype~\cite{AdventureOfALifetime,BorrowingWithoutSorrowing}. Finally, we
outline relevant work on verification and formal semantics of Rust, and briefly
discuss existing tooling and IDE integration. Together, these sections position
the contributions of this project within the current state of the art in making
Rust code easier to evolve and reason about.

\vspace*{-5mm}
\section{Overview of Refactoring}
\label{sec:overview_refactoring}
\vspace{-2mm}
Refactoring is the process of restructuring existing code to improve its internal
structure without changing its externally observable behaviour. It is a key
practice for improving code maintainability and controlling technical debt in
large software projects~\cite{OneThousandOneStories-SoftwareRefactoring}. Modern
IDEs such as Eclipse and IntelliJ IDEA provide a wide range of automated
refactorings, allowing developers to apply semantics-preserving transformations
quickly and, in principle, safely~\cite{AdventureOfALifetime,Formal_Specifiation_JAVA}.

As discussed in Section~\ref{sec:motivation}, empirical studies show that
refactoring is a routine part of professional development, but automated
refactoring tools are not always used to their full potential. Developers often
prefer manual edits, either because they are unfamiliar with the available
refactorings or because they are unsure whether the tool will preserve
behaviour. This motivates research into refactoring tools that are both more
reliable (through stronger guarantees) and more transparent in how they operate.

In this report we focus on the \emph{Extract Method} refactoring, already
introduced in Section~\ref{sec:motivation}. In the refactoring space,
Extract Method is often treated as a basic building block: a contiguous block of code
is moved into a newly created function, and the original code is replaced by a
call to that function. This is used to split long methods into smaller units, to
isolate cohesive behaviour, and as a stepping stone for more complex
refactorings such as Extract Class or Move Method~\cite{Formal_Specifiation_JAVA}.
In garbage-collected languages such as Java or C\#, most implementations are
largely syntactic: they identify the free variables within the selected fragment,
turn them into parameters or return values, and rely on the runtime to manage
object lifetimes and memory.

\begin{paracol}{2}
\setlength{\columnsep}{2em}
\sloppy 
\switchcolumn[0]

The Java example in Listing~\ref{lst:extract-method-java} illustrates this style
of transformation in a language where explicit memory management is not a
concern. A long method containing, for instance, input validation and
transformation logic can be refactored by selecting the validation block,
extracting it into a dedicated method, and replacing the original block with a
call. The resulting code is clearer, and the validation can be tested in
isolation without changing the behaviour of the program.

\switchcolumn

\inputminted[
    fontsize=\scriptsize,
    frame=lines,
    linenos,
    breaklines,
]{java}{Code/refactor_example.java}
\captionsetup{type=listing}
\captionof{listing}{Example of Extract Method refactoring in Java}
\label{lst:extract-method-java}
\end{paracol}

In Rust, the high-level intent of Extract Method is the same, but the
transformation interacts with ownership, borrowing, and lifetimes in ways that
do not arise in typical garbage-collected languages. Understanding these
language features is therefore essential before discussing automated Extract
Method refactoring for Rust.

\vspace*{-5mm}
\section{Rust's Ownership Model \& Semantics}
\label{sec:rusts_ownership_model}

Rust enforces memory safety through a static ownership and borrowing discipline.
Each value has a unique owner; when the owner goes out of scope, the value is
dropped\footnote{We recommend reading this section of Rust By Example \cite{rust_by_example} to better understand lifetimes if this is your first encounter! \\ \url{https://doc.rust-lang.org/rust-by-example/scope/lifetime.html}}. Instead of relying on a garbage collector, Rust uses the type system
and a compile-time borrow checker to prevent use-after-free, data races, and
other common memory errors~\cite{the_rust_language,automated_refactoring_of_rust_programs,automatically_enforcing_rust_trait_properties}.
While these guarantees are attractive for systems programming, they complicate
both manual and automated program transformations, including Extract Method.

\newpage
\vspace*{-2.5mm}
\subsection{Ownership and Moves}
\begin{paracol}{2}
\setlength{\columnsep}{2em}
At the core of Rust's model is the idea that each value has a single owner.
Assigning or passing a value typically moves ownership to a new variable or
function, leaving the previous binding invalid. Listing~\ref{lst:ownership-left} on the right
shows a simple example:

\switchcolumn

\inputminted[
    fontsize=\scriptsize,
    frame=lines,
    linenos,
    breaklines,
]{rust}{Code/ownership_example.rs}

\captionsetup{justification=centering}
\captionsetup{type=listing}
\captionof{listing}{Ownership and moves in Rust}
\label{lst:ownership-left}
\end{paracol}

In this example, the value is moved from \texttt{s1} to \texttt{s2}, making
\texttt{s1} unusable afterwards. An Extract Method transformation that passes
\texttt{s1} into a new function by value may therefore change which scope owns
the value or when it is dropped. Automated refactoring tools must account for
these moves to avoid introducing subtle ownership bugs or compilation failures.

\vspace*{-2.5mm}
\subsection{Borrowing}
Instead of transferring ownership, Rust encourages passing references. A value
can be borrowed immutably (using \icodeverb{&T}) any number of times, or
mutably (using \icodeverb{&mut T}) exactly once at a time. The borrow checker
enforces that mutable and immutable borrows do not conflict, preventing data
races and many classes of aliasing bugs. Listing~\ref{lst:borrowing-imm-mut}
illustrates the basic patterns.

\begin{figure}[H]
    \centering
    \begin{subfigure}[t]{0.47\textwidth}
        \centering
        \inputminted[
            fontsize=\scriptsize,
            frame=lines,
            linenos,
            breaklines,
        ]{rust}{Code/borrowing_example_0.rs}
        \captionsetup{justification=centering}
        \sublistingcaption{Immutable borrow: many readers allowed}
        \label{lst:borrow-immutable}
    \end{subfigure}
    \hfill
    \begin{subfigure}[t]{0.47\textwidth}
        \centering
        \inputminted[
            fontsize=\scriptsize,
            frame=lines,
            linenos,
            breaklines,
        ]{rust}{Code/borrowing_example_1.rs}
        \captionsetup{justification=centering}
        \sublistingcaption{Mutable borrow: a single writer}
        \label{lst:borrow-mutable}
    \end{subfigure}
    \captionsetup{type=listing,justification=centering}
    \caption{Borrowing in Rust}
    \label{lst:borrowing-imm-mut}
\end{figure}

When a block of code is extracted into a new function, the tool must decide for
each captured variable whether to move it, borrow it immutably, or borrow it
mutably. Poor choices can cause the borrow checker to reject the refactored
program or force the tool to introduce unnecessary clones that change
performance characteristics. This is one of the core challenges for designing an Extract
Method algorithm in Rust.

\vspace*{-2.5mm}
\subsection{Lifetimes and Inference}
The Rust compiler tracks how long references remain valid using lifetime
parameters. Many simple cases do not require explicit annotations because the
compiler can infer relationships between input and output lifetimes. For
example, the function in Listing~\ref{lst:lifetime-inference} can be written
without explicit lifetime parameters:

\begin{figure}[h]
    \inputminted[frame=none, linenos=false]{rust}{Code/compiler_lifetime_inference_0.rs}
    \captionof{listing}{\small How we as developers write Rust code}
    \captionsetup{justification=raggedright}
    \label{lst:lifetime-inference}
\end{figure}

\vspace{-2.5mm}
Conceptually, the compiler treats this as if the programmer had written
Listing~\ref{lst:lifetime-expanded}, introducing an explicit lifetime
\icodeverb{'a} shared by the argument and result:

\begin{figure}[h]
    \inputminted[frame=none, linenos=false]{rust}{Code/compiler_lifetime_inference_1.rs}
    \captionof{listing}{\small How the Rust compiler ``sees'' Rust Code}
    \captionsetup{justification=raggedright}
    \label{lst:lifetime-expanded}
\end{figure}

\vspace{-2.5mm}
When code is extracted into a new function, however, the relationships between
references can become more complex, and the compiler may no longer be able to
infer lifetimes automatically. In such cases, explicit lifetime parameters are
required on the extracted function. Automated refactoring tools must therefore
be prepared to introduce, propagate, and most importantly simplify lifetime annotations as part
of the transformation.

\vspace*{-2.5mm}
\subsection{Non-local Control Flow}
Rust allows \icodeverb{return}, \icodeverb{break}, and \icodeverb{continue}
inside nested blocks and loops. Extracting a fragment that contains such
statements into a separate function changes the control-flow structure: an early
\icodeverb{return} from the original function becomes a \icodeverb{return} from
the extracted function instead. Any realistic Extract Method implementation for
Rust must either forbid such cases or explicitly encode and reconstruct
non-local control flow. This point will be revisited in the discussion of the
REM tool in Section~\ref{sec:rem_background}.

Overall, Rust's ownership, borrowing, lifetimes, and control-flow constructs
provide strong safety guarantees but tightly couple data flow, control flow, and
scope. This makes even seemingly local refactorings, such as Extract Method,
significantly more complex than in more permissive, garbage-collected
languages.

\vspace*{-5mm}
\section{Automated Refactoring Techniques for Rust}
\label{sec:automated_refactoring_techniques}

\vspace*{-2.5mm}
\subsection{Renaming and Simple Refactorings}
One of the first efforts to build a Rust refactoring tool was by G. Sam et al.
(2017), who created a proof-of-concept refactoring framework utilizing the Rust
compiler's internal APIs. The team partnered with Mozilla Research\footnote{Mozilla Research were the first major sponsors of the Rust project, and have been a driving force in its development over the last ten years. \cite{rust_wikipedia_2025}. \\ \url{https://blog.mozilla.org/en/mozilla/mozilla-welcomes-the-rust-foundation/}} to be among
the first to implement the Rust specific refactorings of \textit{Lifetime
Elision} and \textit{Lifetime Reification}. This allowed their program to
introuce explicit lifetime parameters in instances where the compiler was
implicitly inferring them - a refactoring that was brand new to Rust. The
challenges encountered illustrated how Rust's stricter scoping and shadowing
rules required careful handling of name conflicts during renaming (e.g. avoiding
situations where renaming a variable could unintentionally shadow another)
\cite{automated_refactoring_of_rust_programs}. Additionally, the 2017 study
concluded that many refactorings are possible with Rust's compiler
infrastructure, but ensuring \textit{behavioural preservation} (especially
around ownership transfers) requires additional static analyses not needed in
langauges without Rust's constraints. Their work on \textit{Lifetime Elision}
has since formed part of the REM toolchain, where the rich feedback from the
Rust compiler is leveraged to ensure that the final transformation is both
valid Rust and as legible as possible \cite{AdventureOfALifetime},
\cite{BorrowingWithoutSorrowing}.

\vspace*{-2.5mm}
\subsection{Extract Method (REM)}
\label{sec:rem_background}
A major advance in automated refactoring for Rust came with the Rusty Extraction
Maestro (REM). Costea et al.'s \emph{Adventure of a Lifetime: Extract Method
Refactoring for Rust}~\cite{AdventureOfALifetime} introduced the theoretical
framework, and Thy et al.'s \emph{Borrowing Without Sorrowing} provided a
practical implementation as an IntelliJ plugin~\cite{BorrowingWithoutSorrowing}.
REM tackles Extract Method in Rust by decomposing it into a sequence of
transformations, each designed to address a specific aspect of Rust's ownership,
borrowing, lifetimes, and control flow.

The process begins with a na\"ive hoisting step that moves the selected block of
code into a new function and replaces the original fragment with a call. This
initial transformation is rarely well-typed. REM then applies a series of
\emph{automated repairs} guided by specialised analyses called \emph{oracles}.
An ownership analysis determines, for each value crossing the new function
boundary, whether it should be passed by value, by shared reference
(\icodeverb{&T}), or by mutable reference (\icodeverb{&mut T}). Other passes
reify non-local control flow by encoding early \icodeverb{return},
\icodeverb{break}, and \icodeverb{continue} statements into an auxiliary enum,
allowing the caller to reconstruct the original behaviour by pattern matching on
the result. A final repair loop iteratively invokes the Rust compiler, uses the
borrow checker's error messages as feedback, and introduces or refines lifetime
parameters until the extracted function type-checks.

Figure~\ref{fig:aol_process} (adapted from~\cite{AdventureOfALifetime}) shows
the overall REM pipeline. Each phase is deliberately simple, but their
composition yields a transformation that can handle (mostly) realistic Rust code. In an
evaluation on real-world projects, REM was able to perform extractions that IDE
tools could not handle, including cases involving multiple interacting borrows
and nested lifetimes~\cite{AdventureOfALifetime}. To the best of our knowledge,
REM's automated lifetime and ownership repair loop remains unique among
refactoring tools for Rust.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{Figures/AoL_algorithm.png}
    \caption{Overview of the REM extract-method pipeline (after Costea et al.~\cite{AdventureOfALifetime})}
    \label{fig:aol_process}
\end{figure}

\vspace{-2.5mm}
Despite these strengths, the original REM prototype is tightly coupled to an
outdated IntelliJ-based Rust frontend and unstable \texttt{rustc} internals, as
discussed in Chapter~\ref{chap:introduction}. This limits its applicability in
modern toolchains. Our project builds on the conceptual design of REM,
particularly its lifetime and ownership repair capabilities, while re-engineering
the implementation around Rust Analyzer and a standalone daemon architecture to
make Extract Method refactoring practical for contemporary Rust development.

\vspace*{-2.5mm}
\subsection{Automated Fixes for Ownership Errors}
Another line of work relevant to Rust refactoring focuses on automatically repairing code that violates ownership or borrowing rules—transforming non-compiling programs into compiling ones without altering semantics. \textit{Rust-Lancet} (Yang et al., ICSE 2024) targets exactly this problem, aiming to fix ownership-rule violations while preserving behaviour. Given a Rust file that fails to compile, Rust-Lancet analyses its AST using \texttt{syn} and \texttt{quote}, applies targeted transformations, and repeatedly rechecks the program until the error is eliminated. Typical repairs include inserting a \icodeverb{clone()} to satisfy ownership constraints or reordering statements to avoid invalid borrows. Crucially, Rust-Lancet includes a behaviour-preservation check: it validates that each proposed fix does not change observable program output, using a specialised semantics for reasoning about programs that do not yet compile.

Across 160 real ownership violation cases, Rust-Lancet successfully repaired a large majority with zero false positives—never introducing an incorrect fix—outperforming both compiler suggestions and several LLM-based baselines. Although positioned as a bug-fixing tool rather than a refactoring engine, its pipeline of semantics-preserving AST rewrites overlaps strongly with automated refactoring. Their results highlight how Rust's strict ownership model can guide automated transformations: once the compiler accepts the repaired code and behaviour-preservation checks succeed, the tool can be confident the patch is correct \cite{RustLancet}. 

\vspace*{-5mm}
\section{Verification and Formal Methods for Rust}
\label{sec:verification_formal_methods}
Rust's appeal for building reliable systems has driven a lot of active work and research into
formal semantics and verification. Traditional deductive verification and model
checking must be adapted to account for Rust's ownership, lifetimes, and
\texttt{unsafe} code, but Rust's strong static guarantees also make many
verification tasks much more manageable when compare to traditional approaches for C or C++.

\vspace*{-2.5mm}
\subsection{RustBelt and Type-System Soundness}
Jung et al.'s \textbf{RustBelt} gives the first machine-checked soundness proof
for a realistic subset of Rust's type system~\cite{RustBelt}. By embedding a
Rust-like calculus ($\lambda$Rust) in the Iris concurrent separation logic and
linking it to low-level memory models, RustBelt shows that well-typed safe Rust
code cannot exhibit undefined behaviour, even when using libraries that contain
\texttt{unsafe} internals. This foundational result allows later work to assume
that safe Rust is memory and thread-safe and focus verification effort either
on functional correctness or on carefully selected \texttt{unsafe}
fragments.

\vspace*{-2.5mm}
\subsection{Verification via Functional Translation}
A complementary approach is to translate Rust programs into pure functional
languages that work with existing proof assistants and verifiers. The CHARON\footnote{\url{https://github.com/AeneasVerif/charon/}}/AENEAS\footnote{\url{https://github.com/AeneasVerif/aeneas}}
toolchain follows this strategy. CHARON translates Rust into an intermediate
representation called \emph{Low-Level Borrow Calculus} (LLBC), which is related
to Rust's MIR but makes the ownership and borrowing structure explicit. AENEAS then
assigns a pure, value-based semantics to LLBC and translates it into a lambda
calculus suitable for verification in tools such as Coq or F*~\cite{AENEAS,
AENEAS_PART_2}. For a large class of Rust programs, this
translation eliminates the need to reason about pointers and heaps directly:
proof engineers can work with a pure functional model, while the design of CHARON/AENEAS
guarantee that proved properties carry back to the original Rust code. Indeed later in this report, (Section~\ref{sec:proof_obligations}) we will rely on this guarantee to back our verification pipeline. 

More recently, Ho et al.\ introduced \emph{symbolic semantics} for Rust and
showed that they form a sound abstraction of concrete heap-based execution for
LLBC programs~\cite{AENEAS_PART_2}. A key outcome is a verified symbolic
interpreter that can serve as a proven-correct borrow checker for LLBC. This
provides strong assurance that tools built on CHARON/AENEAS rest on a solid
semantic foundation and, crucially, the have established a bridge between Rust's informal ownership
intuition and a mathematically precise model.

\vspace*{-2.5mm}
\subsection{Static Analysers and Model Checkers}
Beyond full functional verification, several tools provide lighter-weight
guarantees for Rust. \textit{Prusti} translates annotated Rust code into the
Viper verification language, using Rust's ownership and lifetime information to
encode permissions and prove user-specified pre- and post-conditions and
invariants~\cite{prust_in_practice,prusti_project}. \textit{RefinedRust} extends
this idea with a refinement type system for Rust, allowing rich safety and
correctness properties to be expressed as types and discharged in Coq, even for
some \texttt{unsafe} code~\cite{RefinedRust}.

On the model-checking side, \textit{Kani} is a bounded model checker for Rust
that operates on MIR and generates verification conditions for a SAT/SMT
solver~\cite{verifying_dynamic_trait_objects}. By working at the MIR level, Kani
can reason precisely about traits, generics, and dynamic trait objects, and has
been applied to critical components such as cryptographic libraries. Dynamic
analysers like \textit{Miri} complement these tools by executing Rust programs
in an interpreter that detects undefined behaviour, providing strong testing-time
checks even when full verification is not attempted.

Together, RustBelt, CHARON/AENEAS, Prusti, RefinedRust, Kani, and Miri outline a
rich verification ecosystem. They demonstrate that Rust's ownership discipline is
not only a constraint but also a powerful abstraction layer that verification
tools can exploit.

\vspace*{-5mm}
\section{Integration with IDEs and Langauge Servers}
\label{sec:integration_with_ides}
\vspace{-1mm}
For refactoring and verification tools to be adopted in practice, they must
integrate smoothly into developers' workflows. For Rust, this has centred on
the compiler and the Language Server Protocol (LSP). The original Rust Language
Server (RLS) attempted to repurpose \texttt{rustc}'s internals for IDE support,
but struggled with performance and keeping pace with language evolution. The
community has since converged on \textit{Rust-Analyzer} (RA), a language
server that maintains its own syntax trees and performs incremental type
inference to answer editor queries quickly~\cite{Schiedt_2022}. RA
exposes refactorings and code transformations as “assists” that operate on its
internal representation; and these already include many common refactorings.

Industrial IDEs have also hosted Rust refactoring research. The original REM
prototype was implemented as an extension to the IntelliJ Rust plugin, showing
that research-grade refactorings can be prototyped on top of existing editor
infrastructure~\cite{AdventureOfALifetime,BorrowingWithoutSorrowing}. In
practice, maintaining such integrations is challenging: IDE APIs and Rust
tooling both evolve rapidly. To mitigate this, some tools deliberately avoid
\texttt{rustc} internals and instead rely on stable crates like
\texttt{syn}/\texttt{quote} for parsing and code generation, as in Lancet's
design~\cite{RustLancet}.

At the compiler level, projects like \textit{rustfix} show another style of
integration: \texttt{rustc} emits machine-applicable suggestions for certain
errors and deprecations, which rustfix can apply automatically across a
codebase. While not a general refactoring engine, this mechanism enables
small-scale, behaviour-preserving edits (for example, updating deprecated syntax
or inserting missing lifetime specifiers) driven directly by the compiler. As
Rust's stable analysis APIs mature and RA's assist framework
expands, there is increasing scope for external tools—such as the
\texttt{rem-server} daemon described in this report—to plug into these
ecosystems and offer more advanced, semantics-aware refactorings without being
tied to a single IDE.

\vspace*{-5mm}
\section{Related Work Beyond Rust}
\label{sec:related_work_beyond_rust}
Many of the challenges and opportunities in Rust refactoring echo earlier work
in other languages. Java and C\# have long enjoyed mature IDE support for
refactorings such as \emph{Rename}, \emph{Extract Method}, and \emph{Extract
Class}, and this ecosystem has inspired a large body of research. Beyond classic
examples such as generic-aware refactoring~\cite{GenericRefactoringJAVA}, more
recent work has focused on systematic migration to new language features.
Zhang et al.'s \textit{ReFuture} tool, for example, automatically refactors Java
asynchronous code to use the modern \icodeverb{CompletableFuture} API by combining
static analyses (visitor patterns, alias analysis) with transformation rules, and
has been evaluated on large projects such as Hadoop and ActiveMQ~\cite{AutomaticRefactoringAsyncJAVA}.
In the mobile domain, Lin et al.'s \textit{ASYNCDROID} refactors problematic
uses of Android's \icodeverb{AsyncTask} into safer constructs such as
\icodeverb{IntentService}, addressing common sources of leaks and UI bugs and
showing that domain-specific refactoring rules can be packaged as an IDE
plugin~\cite{AndroidAsncRefactoring}.

Refactoring has also been studied in other paradigms and ecosystems. In Haskell,
the \textit{HaRe} tool brought structured refactoring to a lazy, purely functional
language, handling challenges such as type classes and non-strict evaluation~\cite{HaRe}.
In dynamic languages like JavaScript and Python, the lack of static types has led
to refactoring approaches that rely on heuristics, runtime analysis, or
developer-guided transformations. Meanwhile, tools such as Facebook's \textit{JSCodeshift}
and Python's \textit{Bowler} allow developers to script custom codemods over
ASTs\cite{Bowler}.

Finally, refactoring is closely linked to adjacent areas such as code smell
detection, automated program repair, and large-scale migrations. Some
repair systems use refactoring-like transformations as behaviour-preserving
steps to simplify buggy code before or after applying a fix, and language
servers increasingly act as a common backbone for these capabilities
across many editors~\cite{AdventureOfALifetime}. The Rust work surveyed in this
section fits into this broader landscape: it adapts ideas from mature ecosystems
(Java, Android, \& Haskell) to a language whose ownership-based
semantics demand specialised analyses, but whose strong guarantees can in turn
be exploited by refactoring and verification tools.
