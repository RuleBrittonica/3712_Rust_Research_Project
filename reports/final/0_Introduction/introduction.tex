\chapter{Introduction}
\label{chap:introduction}
\vspace*{-20mm}
% 0.5 pages here 
Rust is a modern systems language that combines low-level control with strong safety guarantees~\cite{the_rust_language}. This is very different to previous norms, where a programmer had to make the choice between low-level control (with languages such as C/C++) and memory safety (with garbage collected languages such as Java). These guarantees, however, make automated refactoring—particularly ``Extract Method''—far more complex than in garbage-collected languages. Prior work such as \textit{Adventure of a Lifetime}\cite{AdventureOfALifetime} and the Rusty Extraction Maestro (REM) prototype\cite{BorrowingWithoutSorrowing} demonstrated that automated extraction in Rust is possible, but only within a narrow fragment of the language and with heavy dependence on unstable tooling. 

This project revisits the problem from first principles, redesigning REM into a standalone, Rust-Analyzer (RA) driven toolchain capable of handling real-world Rust features such as \texttt{async}/\texttt{await}, generics, trait objects, and const contexts, whilst also bringing the execution time down by a factor of five. We also introduce an optional verification pipeline to check that extractions preserve behaviour. Together, these contributions aim to make safe, semantics-preserving extract-method refactoring practical for everyday Rust development rather than a research prototype.

\vspace*{-5mm}
\section{Context and Motivation}
\label{sec:motivation}
% 1-1.5 pages
Modern software is rarely written from scratch. Instead, engineers spend much of their time extending, adapting, and repairing existing codebases. As systems grow, crates gain more responsibilities, functions become longer, and dependencies become more complex. Without a deliberate effort to manage this complexity, technical debt rapidly accumulates and future changes become increasingly costly. Refactoring, the task of restructuring a program's internals without altering its observable behaviour---is one of the main tools developers use to keep codebases maintainable.

Empirical evidence suggests that refactoring is not an occasional clean-up, but a routine part of development practice. A large-scale survey of 1{,}183 developers by JetBrains found that most respondents refactor at least weekly, and many reported spending an hour or more in a single refactoring session~\cite{OneThousandOneStories-SoftwareRefactoring}. This indicates that refactoring is both widespread and potentially time-consuming when performed manually, and that tool support plays an important role in enabling small, safe transformations to be applied regularly.

Within the broad scope of refactorings, \emph{Extract Method} is one of the most common operations. Given a contiguous block of code (for example, the body of a loop), Extract Method moves that block into a new function and replaces the original code with a call to that function. This improves readability by assigning a descriptive name to a piece of logic and shortening long functions, and, by isolating the codes behaviour, we enable reuse and targeted unit testing. In garbage-collected languages such as Java or C\#, performing Extract Method is relatively straightforward: the tool identifies the free variables in the selected fragment, turns them into parameters or return values, and relies on the runtime to manage object lifetimes and memory.

Rust, however, presents additional challenges. As a modern systems programming language, Rust provides C-like control over memory and performance while garunteeing of memory safety through its ownership and borrowing model~\cite{the_rust_language}. Rather than relying on garbage collection, the compiler enforces a static discipline: each value has a unique owner; borrows are restricted in number and kind; and lifetimes are tracked to ensure that references never outlive the data they point to. This eliminates broad classes of bugs, such as use-after-free and many data races, but also tightly couples control-flow structure, data ownership, and aliasing patterns.

As a consequence, na\"ively reusing Extract Method algorithms from garbage-collected languages does not work in Rust. Moving code into a new function can change which scope owns a value or how many mutable and immutable references to that value are simultaneously in play. A transformation that appears harmless at the level of syntax may cause the borrow checker to reject the program, or may alter which parts of the program are permitted to mutate shared state. Even when behaviour is preserved, the transformed code may require explicit lifetime parameters or more complex type signatures, making it harder for developers to read and maintain.

Rust is increasingly used for performance-critical and safety-critical infrastructure. In these domains, developers want both the maintainability benefits of refactoring and the safety guarantees that motivate the use of Rust. If refactoring tools frequently break compilation, produce unreadable code, or fail to support common language features such as \icodeverb{async/await}, closures, and generics, developers are less likely to rely on them and may instead resort to manual editing or just ignoring the problem. 

Prior work has shown that non-trivial Extract Method refactoring in Rust is possible. In particular, \emph{Adventure of a Lifetime} (AoL) and the associated Rusty Extraction Maestro (REM) prototype introduced a Rust-specific refactoring pipeline that explicitly reasons about ownership, borrowing, and non-local control flow~\cite{AdventureOfALifetime}. However, the original REM implementation is tightly coupled to an outdated IntelliJ IDEA-based Rust frontend and heavily relies on highly unstable \texttt{rustc} internals, which at best result in behaviour changes from one version of \texttt{rustc} to the next. It also provides no guarantees of semantic preservation beyond the informal assurance of passing tests. This project is motivated by the gap between the clear need for robust refactoring support in real-world Rust development and the current lack of comprehensive, lifetime-aware tools that integrate into modern Rust workflows.

\vspace*{-5mm}
\section{Problem Statement}
\label{sec:problem_statememt}
\vspace{-2.5mm}
% 0.75-1 page
Current IDE support for Extract Method in Rust is adequate for simple cases, but limited when code involves realistic borrowing patterns, complex generics, macros, or asynchronous constructs. Tools such as RA and the IntelliJ-based plugins generally succeed on small, local fragments, but tend either to refuse more complex refactorings or to produce code that no longer compiles. They also do not attempt to repair lifetimes or ownership, and they provide no guarantees that the refactoring has preserved behaviour.

The Rusty Extraction Maestro (REM) prototype from \emph{Adventure of a Lifetime}~\cite{AdventureOfALifetime} addressed some of these shortcomings by introducing Rust-specific analyses and, in particular, an automated lifetime and ownership repair loop. After applying an Extract Method transformation, REM iteratively adjusts the extracted function's signature in response to compiler feedback until the borrow checker accepts it. To the best of our knowledge, this form of automated lifetime repair is not available in any other refactoring tool for Rust. However, REM remains a research prototype: it is tied to an obsolete IntelliJ-based frontend and fragile \texttt{rustc} internals, it incurs substantial latency due to repeated \texttt{cargo check} invocations, and its support for advanced language features such as \icodeverb{async}/\icodeverb{await}, closures, complex generics, macros, and partial moves of struct fields is non-existent. 

A further limitation, shared by both REM and IDE-native refactorings, is the lack of strong guarantees that transformations preserve program behaviour. REM performs complex structural changes, including modifications to function boundaries and ownership patterns, and may introduce auxiliary types or explicit lifetime parameters. Test suites can provide some assurance that the refactored program behaves as intended, but they are necessarily incomplete and only indicate that an error exists, not where it was introduced. For a refactoring tool intended to operate on non-trivial Rust code, there is a clear need for an updated design that combines REM's advanced lifetime-repair capabilities with modern toolchain support and a lightweight verification pipeline that offers stronger evidence of behaviour preservation.

\vspace*{-5mm}
\section{Project Aims}
\label{sec:project_aims}
\vspace{-2.5mm}
% 0.5 - 0.75 page
This project aims to turn the original REM prototype into a practical tool for modern Rust development. The first goal is to re-engineer REM as a standalone pipeline that no longer relies on outdated IntelliJ-based infrastructure or fragile \texttt{rustc} internals, and to extend its Extract Method capabilities to better handle modern Rust language features such as \icodeverb{async}/\icodeverb{await}, closures, macros, and more complex uses of generics.

The second goal is to connect our Extract Method refactorings to a equivalence checking pathway that can provide stronger evidence of semantic preservation than tests alone. Specifically, the project aims to integrate REM with existing verification-oriented toolchains (in particular CHARON and AENEAS) so that refactorings can be translated into a form suitable for logical reasoning about equivalence between the original and refactored code.

The third goal is to expose all of this new functionality through an interface that fits naturally into existing workflows. This includes a command-line interface suitable for scripting and batch evaluation, as well as a Visual Studio Code extension that allows developers to invoke REM directly from the editor. A longer-term ambition, which is beyond the scope of this project, is to explore integration with RA itself, for example by reusing its intermediate representations more directly or embedding a subset of REM's analysis into the language server.

\vspace*{-5mm}
\section{Key Contributions}
\label{sec:key_contributions}
\vspace{-2.5mm}
% 0.75 - 1 page
To achieve these aims, this project makes the following contributions:

\textbf{A re-engineered REM core for modern toolchains.}
The original REM implementation has been refactored into a standalone Extract Method pipeline that decouples the analysis and transformation logic from the obsolete IntelliJ-based frontend and fragile \texttt{rustc} internals. The new daemon based approach is readily compatible with existing IDEs and workflows. \\
\textbf{Integration with Rust Analyzer for fast, in-memory analysis.}
The project introduces a new extraction engine that builds on RA's semantic information and in-memory workspace model. This gives REM2.0 a far deeper semantic understanding of code than previous AST-based approaches. \\
\textbf{Extended extraction coverage for modern Rust features.}
The Extract Method pipeline has been extended to support a broad range of real-world Rust constructs including selected uses of \texttt{async}/\texttt{await}, generics, non-local control flow, const evaluation, and higher-ranked trait bounds. \\
\textbf{Editor/IDE integration via \texttt{rem-server} and VSCode.}
The core implementation is exposed as \texttt{rem-server}, a long-running JSON-RPC process suitable for integration with arbitrary IDEs. A lightweight CLI and prototype VSCode extension demonstrate practical usage today.\footnote{REM-VSCode is available on the VSCode marketplace, \url{https://marketplace.visualstudio.com/items?itemName=MatthewBritton.remvscode}} \\
\textbf{A prototype equivalence checking pipeline using CHARON and AENEAS.}
REM2.0 leverages recent advances in program verification to translate Rust into proof-oriented functional languages such as Coq, enabling automated behavioural equivalence checking for Extract Method refactorings. \\
\textbf{An empirical evaluation on many real-world Rust projects.}
We evaluate the REM pipeline across a suite of widely used Rust projects, measuring coverage, performance, and failure modes. This demonstrates that the new architecture preserves REM’s strengths—particularly automated lifetime and ownership repair—while significantly improving practical applicability and language coverage.

\vspace*{-5mm}
\section{Method Overview and Scope}
\label{sec:method-overview-scope}
\vspace{-2.5mm}
At a high level, this project constructs a multi-stage Extract Method pipeline for Rust and evaluates it on real-world codebases. The core extraction and analysis stages reuse RA's in-memory workspace and semantic information to identify candidate fragments and generate initial refactorings. A dedicated repairer then processes the extracted functions fixing lifetimes, and ownership patterns until the transformed code is valid Rust. For a selected subset of examples, the original and refactored programs are translated via CHARON and AENEAS into verification-oriented intermediate representations, enabling reasoning about semantic preservation. The resulting toolchain is exposed through a JSON-RPC server (\texttt{rem-server})\footnote{https://crates.io/crates/rem-server}, a lightweight CLI (\texttt{rem-cli})\footnote{https://crates.io/crates/rem-command-line}, and a Visual Studio Code extension, and is evaluated on a suite of open-source Rust crates. The scope of this work is limited to Extract Method refactorings; other refactoring operators are not considered. Support for macros and very complex generic patterns remains partial, and the verification pipeline is applied only to representative case studies rather than entire codebases. Full integration into RA itself is treated as a long-term direction rather than an immediate goal.

\vspace*{-5mm}
\section{Structure of This Report}
\label{sec:structure}
\vspace{-2.5mm}
% 0.25 - 0.5 page
The remainder of this report is structured as follows. Chapter~\ref{chap:lit_review} provides the background on refactoring, Rust's ownership and borrowing model, and prior work, with a particular focus on \emph{Adventure of a Lifetime} and the original REM prototype\cite{BorrowingWithoutSorrowing}. Chapter~\ref{chap:expanding_rem} presents the design of the re-engineered REM pipeline, including its integration with RA and the overall architecture of \texttt{rem-server}. Chapter~\ref{chap:verification} details the need for, design of, and capabilities of the verification pipeline. Chapter~\ref{chap:evaluation_experimental_results} then provides an empirical evaluation of the new toolchain on a set of real-world Rust projects (both new and drawn from Adventure of a Lifetime) and case studies drawn from the verification pipeline. Chapter~\ref{chap:conclusions_future_work} discusses limitations, design trade-offs, and opportunities for future work, before concluding. Various appendices are attached, detailing specific code fragments, our complete set of results, and other relevant information.  