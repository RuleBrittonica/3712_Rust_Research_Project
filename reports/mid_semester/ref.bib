@article{AdventureOfALifetime,
    author = {Thy, Sewen and Costea, Andreea and Gopinathan, Kiran and Sergey, Ilya},
    title = {Adventure of a Lifetime: Extract Method Refactoring for Rust},
    year = {2023},
    issue_date = {October 2023},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    volume = {7},
    number = {OOPSLA2},
    url = {https://doi.org/10.1145/3622821},
    doi = {10.1145/3622821},
    journal = {Proc. ACM Program. Lang.},
    month = oct,
    articleno = {245},
    numpages = {28},
    keywords = {program repair, automated code refactoring, Rust}
}

@article{BorrowingWithoutSorrowing,
  author = {Sewen Thy},
  title = {Borrowing without Sorrowing: Implementing Extract Method Refactoring for Rust},
  year = {2023},
  url= {https://verse-lab.github.io/papers/Sewen-Thy-Capstone.pdf}
}

@article{rbooka,
  author = {Matsakis, Nicholas Turon, Aaron},
  title = {The Rust RFC Book: Statements and Expressions},
  url = {https://doc.rust-lang.org/reference/statements-and-expressions.html},
  year = {2020}
}words = {verification, functional translation, Rust}
}

@article{rbookb,
  author = {Matsakis, Nicholas Turon, Aaron},
  title = {The Rust RFC Book: Lifetime Elision},
  url = {https://doc.rust-lang.org/nomicon/lifetime-elision.html},
  year = {2020}
}

@article{ProvingCompilerOptimisations,
  author = {Lerner, Sorin and Millstein, Todd and Chambers, Craig},
  title = {Automatically proving the correctness of compiler optimizations},
  year = {2003},
  issue_date = {May 2003},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {38},
  number = {5},
  issn = {0362-1340},
  url = {https://doi.org/10.1145/780822.781156},
  doi = {10.1145/780822.781156},
  abstract = {We describe a technique for automatically proving compiler optimizations sound, meaning that their transformations are always semantics-preserving. We first present a domain-specific language, called Cobalt, for implementing optimizations as guarded rewrite rules. Cobalt optimizations operate over a C-like intermediate representation including unstructured control flow, pointers to local variables and dynamically allocated memory, and recursive procedures. Then we describe a technique for automatically proving the soundness of Cobalt optimizations. Our technique requires an automatic theorem prover to discharge a small set of simple, optimization-specific proof obligations for each optimization. We have written a variety of forward and backward intraprocedural dataflow optimizations in Cobalt, including constant propagation and folding, branch folding, full and partial redundancy elimination, full and partial dead assignment elimination, and simple forms of points-to analysis. We implemented our soundness-checking strategy using the Simplify automatic theorem prover, and we have used this implementation to automatically prove our optimizations correct. Our checker found many subtle bugs during the course of developing our optimizations. We also implemented an execution engine for Cobalt optimizations as part of the Whirlwind compiler infrastructure.},
  journal = {SIGPLAN Not.},
  month = may,
  pages = {220–231},
  numpages = {12},
  keywords = {automated correctness proofs, compiler optimization}
}

@article{DUGGAN199637,
  title = {Explaining type inference},
  journal = {Science of Computer Programming},
  volume = {27},
  number = {1},
  pages = {37-83},
  year = {1996},
  issn = {0167-6423},
  doi = {https://doi.org/10.1016/0167-6423(95)00007-0},
  url = {https://www.sciencedirect.com/science/article/pii/0167642395000070},
  author = {Dominic Duggan and Frederick Bent},
  abstract = {Type inference is the compile-time process of reconstructing missing type information in a program based on the usage of its variables. ML and Haskell are two languages where this aspect of compilation has enjoyed some popularity, allowing type information to be omitted while static type checking is still performed. Type inference may be expected to have some application in the prototyping and scripting languages which are becoming increasingly popular. A difficulty with type inference is the confusing and sometimes counter-intuitive diagnostics produced by the type checker as a result of type errors. A modification of the unification algorithm used in Hindley-Milner type inference is presented, which allows the specific reasoning which led to a program variable having a particular type to be recorded for type explanation. This approach is close to the intuitive process used in practice for debugging type errors. The algorithm is practical, and has been implemented in the Standard ML of New Jersey compiler. The modified unification algorithm also appears useful in other domains, including logic program debuggers and semantics-based programming environments.}
}

@article{ExtractMethodLitReview,
  author = {Alomar, Eman and Mkaouer, Mohamed Wiem and Ouni, Ali},
  year = {2023},
  month = {12},
  pages = {},
  title = {Behind the Intent of Extract Method Refactoring A Systematic Literature Review},
  volume = {PP},
  journal = {IEEE Transactions on Software Engineering},
  doi = {10.1109/TSE.2023.3345800}
}

@article{GenericRefactoringJAVA,
  author={Marticorena, Raul and López, Carlos and Crespo, Yania and Pérez, F. Javier},
  booktitle={2010 14th European Conference on Software Maintenance and Reengineering},
  title={Refactoring Generics in JAVA: A Case Study on Extract Method},
  year={2010},
  volume={},
  number={},
  pages={212-221},
  keywords={Java;Software;Input variables;Arrays;Indexes;Feature extraction;generics;generic programming;refactoring;extract method;test cases},
  doi={10.1109/CSMR.2010.38}
}

@article{AutomaticRefactoringAsyncJAVA,
  AUTHOR = {Zhang, Yang and Xie, Zhaoyang and Yue, Yanxia and Qi, Lin},
  TITLE = {Automatic Refactoring Approach for Asynchronous Mechanisms with CompletableFuture},
  JOURNAL = {Applied Sciences},
  VOLUME = {14},
  YEAR = {2024},
  NUMBER = {19},
  ARTICLE-NUMBER = {8866},
  URL = {https://www.mdpi.com/2076-3417/14/19/8866},
  ISSN = {2076-3417},
  ABSTRACT = {To address the inherent limitations of Future in asynchronous programming frameworks, JDK 1.8 introduced the CompletableFuture class, which features approximately 50 different methods for composing and executing asynchronous computations and handling exceptions. This paper proposes an automatic refactoring method that integrates multiple static analysis techniques, including visitor pattern analysis, alias analysis, and executor inheritance structure analysis, to conduct precondition checks. Distinct from existing Future refactoring methods, this approach considers custom executor types, thereby extending its applicability. Using this method, the ReFuture automatic refactoring plugin was implemented within the Eclipse JDT framework. The method was evaluated in terms of the number of refactorings, refactoring time, and error introduction, alongside a side-by-side comparison with the existing method. The refactoring outcomes for nine large applications, including ActiveMQ, Hadoop, and Elasticsearch, show that ReFuture successfully refactored 639 out of 813 potential code structures, achieving a refactoring success rate of 64.70% without introducing errors. This tool effectively facilitates the refactoring to CompletableFuture and enhances refactoring efficiency compared to manual methods.},
  DOI = {10.3390/app14198866}
}

@article{AndroidAsncRefactoring,
  author={Lin, Yu and Okur, Semih and Dig, Danny},
  booktitle={2015 30th IEEE/ACM International Conference on Automated Software Engineering (ASE)},
  title={Study and Refactoring of Android Asynchronous Programming (T)},
  year={2015},
  volume={},
  number={},
  pages={224-235},
  keywords={Androids;Humanoid robots;Graphical user interfaces;Receivers;Programming;Registers;Transforms;Refactoring;Android;Asynchronous},
  doi={10.1109/ASE.2015.50}
}
