(** THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS *)
(** [extract] *)
Require Import Primitives.
Import Primitives.
Require Import Coq.ZArith.ZArith.
Require Import List.
Import ListNotations.
Local Open Scope Primitives_scope.
Module Extract.

(** Trait declaration: [core::cmp::PartialEq]
    Source: '/rustc/library/core/src/cmp.rs', lines 251:0-251:65
    Name pattern: [core::cmp::PartialEq] *)
Record core_cmp_PartialEq_t (Self : Type) (Rhs : Type)
  := mkcore_cmp_PartialEq_t {
  core_cmp_PartialEq_t_eq : Self -> Rhs -> result bool;
}.

Arguments mkcore_cmp_PartialEq_t { _ } { _ }.
Arguments core_cmp_PartialEq_t_eq { _ } { _ } _.

(** [core::array::equality::{core::cmp::PartialEq<@Array<U, N>> for @Array<T, N>}::eq]:
    Source: '/rustc/library/core/src/array/equality.rs', lines 10:4-10:40
    Name pattern: [core::array::equality::{core::cmp::PartialEq<[@T; @N], [@U; @N]>}::eq] *)
Axiom core_array_equality_PartialEqArrayArray_eq :
  forall{T : Type} {U : Type} {N : usize} (cmpPartialEqInst :
        core_cmp_PartialEq_t T U),
        array T N -> array U N -> result bool
.

(** Trait implementation: [core::array::equality::{core::cmp::PartialEq<@Array<U, N>> for @Array<T, N>}]
    Source: '/rustc/library/core/src/array/equality.rs', lines 5:0-7:28
    Name pattern: [core::cmp::PartialEq<[@T; @N], [@U; @N]>] *)
Definition core_cmp_PartialEqArrayArray {T : Type} {U : Type} (N : usize)
  (cmpPartialEqInst : core_cmp_PartialEq_t T U) : core_cmp_PartialEq_t (array T
  N) (array U N) := {|
  core_cmp_PartialEq_t_eq := core_array_equality_PartialEqArrayArray_eq
    cmpPartialEqInst;
|}.

(** [core::array::{core::clone::Clone for @Array<T, N>}::clone]:
    Source: '/rustc/library/core/src/array/mod.rs', lines 444:4-444:27
    Name pattern: [core::array::{core::clone::Clone<[@T; @N]>}::clone] *)
Axiom core_array_CloneArray_clone :
  forall{T : Type} {N : usize} (cloneCloneInst : core_clone_Clone T),
        array T N -> result (array T N)
.

(** Trait implementation: [core::array::{core::clone::Clone for @Array<T, N>}]
    Source: '/rustc/library/core/src/array/mod.rs', lines 442:0-442:47
    Name pattern: [core::clone::Clone<[@T; @N]>] *)
Definition core_clone_CloneArray {T : Type} (N : usize) (cloneCloneInst :
  core_clone_Clone T) : core_clone_Clone (array T N) := {|
  core_clone_Clone_clone := core_array_CloneArray_clone cloneCloneInst;
|}.

(** Trait implementation: [core::array::{core::marker::Copy for @Array<T, N>}]
    Source: '/rustc/library/core/src/array/mod.rs', lines 439:0-439:45
    Name pattern: [core::marker::Copy<[@T; @N]>] *)
Definition core_marker_CopyArray {T : Type} (N : usize) (markerCopyInst :
  core_marker_Copy T) : core_marker_Copy (array T N) := {|
  cloneInst := core_clone_CloneArray N markerCopyInst.(cloneInst);
|}.

(** [core::cmp::impls::{core::cmp::PartialEq<i32> for i32}::eq]:
    Source: '/rustc/library/core/src/cmp.rs', lines 1865:16-1865:50
    Name pattern: [core::cmp::impls::{core::cmp::PartialEq<i32, i32>}::eq] *)
Axiom core_cmp_impls_PartialEqI32I32_eq : i32 -> i32 -> result bool.

(** [core::fmt::Arguments]
    Source: '/rustc/library/core/src/fmt/mod.rs', lines 618:0-618:24
    Name pattern: [core::fmt::Arguments] *)
Axiom core_fmt_Arguments_t : Type.

(** [core::panicking::AssertKind]
    Source: '/rustc/library/core/src/panicking.rs', lines 378:0-378:19
    Name pattern: [core::panicking::AssertKind] *)
Inductive core_panicking_AssertKind_t :=
| Core_panicking_AssertKind_Eq : core_panicking_AssertKind_t
| Core_panicking_AssertKind_Ne : core_panicking_AssertKind_t
| Core_panicking_AssertKind_Match : core_panicking_AssertKind_t
.

(** [extract::bump_extracted]:
    Source: 'src/main.rs', lines 1:0-8:1 *)
Definition bump_extracted
  {N : usize} (coremarkerCopyArrayI32NInst : core_marker_Copy (array i32 N))
  (arr : array i32 N) (i : usize) (mark : bool) :
  result unit
  :=
  i1 <- array_index_usize arr i;
  if i1 s= 0%i32
  then (_ <- i32_add i1 1%i32; _ <- array_index_mut_usize arr i; Ok tt)
  else (_ <- i32_add i1 1%i32; _ <- array_index_mut_usize arr i; Ok tt)
.

(** [extract::bump]: loop 0:
    Source: 'src/main.rs', lines 16:4-19:5 *)
Fixpoint bump_loop0
  {N : usize} (coremarkerCopyArrayI32NInst : core_marker_Copy (array i32 N))
  (arr : array i32 N) (k : usize) (mark : bool) (i : usize) :
  result unit
  :=
  if i s< k
  then (
    a <- coremarkerCopyArrayI32NInst.(cloneInst).(core_clone_Clone_clone) arr;
    _ <- bump_extracted coremarkerCopyArrayI32NInst a i mark;
    i1 <- usize_add i 1%usize;
    bump_loop0 coremarkerCopyArrayI32NInst arr k mark i1)
  else Ok tt
.

(** [extract::bump]: loop 1:
    Source: 'src/main.rs', lines 16:4-19:5 *)
Fixpoint bump_loop1
  {N : usize} (coremarkerCopyArrayI32NInst : core_marker_Copy (array i32 N))
  (arr : array i32 N) (mark : bool) (i : usize) :
  result unit
  :=
  if i s< N
  then (
    a <- coremarkerCopyArrayI32NInst.(cloneInst).(core_clone_Clone_clone) arr;
    _ <- bump_extracted coremarkerCopyArrayI32NInst a i mark;
    i1 <- usize_add i 1%usize;
    bump_loop1 coremarkerCopyArrayI32NInst arr mark i1)
  else Ok tt
.

(** [extract::bump]:
    Source: 'src/main.rs', lines 9:0-20:1 *)
Definition bump
  {N : usize} (coremarkerCopyArrayI32NInst : core_marker_Copy (array i32 N))
  (arr : array i32 N) (k : usize) (mark : bool) :
  result ((array i32 N) * bool)
  :=
  if k s< N
  then (
    _ <- bump_loop0 coremarkerCopyArrayI32NInst arr k mark 0%usize;
    Ok (arr, mark))
  else (
    _ <- bump_loop1 coremarkerCopyArrayI32NInst arr mark 0%usize;
    Ok (arr, mark))
.

(** [extract::main]:
    Source: 'src/main.rs', lines 21:0-27:1 *)
Definition main : result unit :=
  p <-
    bump (core_marker_CopyArray 4%usize core_marker_CopyI32)
      (mk_array 4%usize [ 0%i32; 0%i32; 5%i32; 9%i32 ]) 3%usize false;
  let (a, touched_zero) := p in
  b <-
    core_array_equality_PartialEqArrayArray_eq core_cmp_PartialEqI32 a
      (mk_array 4%usize [ 1%i32; 1%i32; 6%i32; 9%i32 ]);
  if b then massert touched_zero else Fail_ Failure
.

End Extract.
